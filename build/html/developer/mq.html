

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Messaging and Queues &mdash; buildbot-translate 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> buildbot-translate
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">1. Buildbot Tutorial</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">buildbot-translate</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Messaging and Queues</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/developer/mq.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="messaging-and-queues">
<span id="id1"></span><h1>Messaging and Queues<a class="headerlink" href="#messaging-and-queues" title="Permalink to this headline">¶</a></h1>
<p>Buildbot uses a message-queueing structure to handle asynchronous notifications in a distributed fashion.
This avoids, for the most part, the need for each master to poll the database, allowing masters to react to events as they happen.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Buildbot is structured as a hybrid state- and event-based application, which will probably offend adherents of either pattern.
In particular, the most current state is stored in the <a class="reference internal" href="database.html"><span class="doc">Database</span></a>, while any changes to the state are announced in the form of a message.
The content of the messages is sufficient to reconstruct the updated state, allowing external processes to represent “live” state without polling the database.</p>
<p>This split nature immediately brings to light the problem of synchronizing the two interfaces.
Queueing systems can introduce queueing delays as messages propagate.
Likewise, database systems may introduce a delay between committed modifications and the modified data appearing in queries; for example, with MySQL master/slave replication, there can be several seconds’ delay before a slave is updated.</p>
<p>Buildbot’s MQ connector simply relays messages, and makes no attempt to coordinate the timing of those messages with the corresponding database updates.
It is up to higher layers to apply such coordination.</p>
</div>
<div class="section" id="connector-api">
<h2>Connector API<a class="headerlink" href="#connector-api" title="Permalink to this headline">¶</a></h2>
<p>All access to the queueing infrastructure is mediated by an MQ connector.
The connector’s API is defined below.
The connector itself is always available as <code class="docutils literal notranslate"><span class="pre">master.mq</span></code>, where <code class="docutils literal notranslate"><span class="pre">master</span></code> is the current <code class="xref py py-class docutils literal notranslate"><span class="pre">BuildMaster</span></code> instance.</p>
<span class="target" id="module-buildbot.mq.base"></span><p>The connector API is quite simple.
It is loosely based on AMQP, although simplified because there is only one exchange (see <a class="reference internal" href="#queue-schema"><span class="std std-ref">Queue Schema</span></a>).</p>
<p>All messages include a “routing key”, which is a tuple of <em>7-bit ascii</em> strings describing the content of the message.
By convention, the first element of the tuple gives the type of the data in the message.
The last element of the tuple describes the event represented by the message.
The remaining elements of the tuple describe attributes of the data in the message that may be useful for filtering; for example, buildsets may usefully be filtered on buildsetids.
The topics and associated message types are described below in <a class="reference internal" href="#message-schema"><span class="std std-ref">Message Schema</span></a>.</p>
<p>Filters are also specified with tuples.
For a filter to match a routing key, it must have the same length, and each element of the filter that is not None must match the corresponding routing key element exactly.</p>
<dl class="class">
<dt id="buildbot.mq.base.MQConnector">
<em class="property">class </em><code class="sig-prename descclassname">buildbot.mq.base.</code><code class="sig-name descname">MQConnector</code><a class="headerlink" href="#buildbot.mq.base.MQConnector" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an abstract parent class for MQ connectors, and defines the interface.
It should not be instantiated directly.
It is a subclass of <a class="reference internal" href="utils.html#buildbot.util.service.AsyncService" title="buildbot.util.service.AsyncService"><code class="xref py py-class docutils literal notranslate"><span class="pre">buildbot.util.service.AsyncService</span></code></a>, and subclasses can override service methods to start and stop the connector.</p>
<dl class="method">
<dt id="buildbot.mq.base.MQConnector.produce">
<code class="sig-name descname">produce</code><span class="sig-paren">(</span><em class="sig-param">routing_key</em>, <em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#buildbot.mq.base.MQConnector.produce" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>routing_key</strong> (<em>tuple</em>) – the routing key for this message</p></li>
<li><p><strong>data</strong> – JSON-serializable body of the message</p></li>
</ul>
</dd>
</dl>
<p>This method produces a new message and queues it for delivery to any associated consumers.</p>
<p>The routing key and data should match one of the formats given in <a class="reference internal" href="#message-schema"><span class="std std-ref">Message Schema</span></a>.</p>
<p>The method returns immediately; the caller will not receive any indication of a failure to transmit the message, although errors will be displayed in <code class="docutils literal notranslate"><span class="pre">twistd.log</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="buildbot.mq.base.MQConnector.startConsuming">
<code class="sig-name descname">startConsuming</code><span class="sig-paren">(</span><em class="sig-param">callback</em>, <em class="sig-param">filter</em><span class="optional">[</span>, <em class="sig-param">persistent_name=name</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#buildbot.mq.base.MQConnector.startConsuming" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>callback</strong> – callable to invoke for matching messages</p></li>
<li><p><strong>filter</strong> (<em>tuple</em>) – filter for routing keys of interest</p></li>
<li><p><strong>persistent_name</strong> – persistent name for this consumer</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="#buildbot.mq.base.QueueRef" title="buildbot.mq.base.QueueRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueRef</span></code></a> instance via Deferred</p>
</dd>
</dl>
<p>This method will begin consuming messages matching the filter, invoking <code class="docutils literal notranslate"><span class="pre">callback</span></code> for each message.
See above for the format of the filter.</p>
<p>The callback will be invoked with two arguments: the message’s routing key and the message body, as a Python data structure.
It may return a Deferred, but no special processing other than error handling will be applied to that Deferred.
In particular, note that the callback may be invoked a second time before the Deferred from the first invocation fires.</p>
<p>A message is considered delivered as soon as the callback is invoked - there is no support for acknowledgements or re-queueing unhandled messages.</p>
<p>Note that the timing of messages is implementation-dependent.
It is not guaranteed that messages sent before the <a class="reference internal" href="#buildbot.mq.base.MQConnector.startConsuming" title="buildbot.mq.base.MQConnector.startConsuming"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startConsuming()</span></code></a> method completes will be received.
In fact, because the registration process may not be immediate, even messages sent after the method completes may not be received.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">persistent_name</span></code> is given, then the consumer is assumed to be persistent, and consumption can be resumed with the given name.
Messages that arrive when no consumer is active are queued and will be delivered when a consumer becomes active.</p>
</dd></dl>

<dl class="method">
<dt id="buildbot.mq.base.MQConnector.waitUntilEvent">
<code class="sig-name descname">waitUntilEvent</code><span class="sig-paren">(</span><em class="sig-param">filter</em>, <em class="sig-param">check_callback</em><span class="sig-paren">)</span><a class="headerlink" href="#buildbot.mq.base.MQConnector.waitUntilEvent" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filter</strong> (<em>tuple</em>) – filter for routing keys of interest</p></li>
<li><p><strong>check_callback</strong> (<em>function</em>) – a callback which check if the event has already happened</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a Deferred that fires when the event has been received, and contain tuple (routing_key, value) representing the event</p>
</dd>
</dl>
<p>This method is a helper which returns a defer that fire when a certain event has occurred.
This is useful for waiting the end of a build or disconnection of a worker.
You shall make sure when using this method that this event will happen in the future, and take care of race conditions.
For that caller must provide a check_callback which will check of the event has already occurred.
The whole race-condition-free process is:</p>
<ul class="simple">
<li><p>Register to event</p></li>
<li><p>Check if it has already happened</p></li>
<li><p>If not wait for the event</p></li>
<li><p>Unregister from event</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="buildbot.mq.base.QueueRef">
<em class="property">class </em><code class="sig-prename descclassname">buildbot.mq.base.</code><code class="sig-name descname">QueueRef</code><a class="headerlink" href="#buildbot.mq.base.QueueRef" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#buildbot.mq.base.QueueRef" title="buildbot.mq.base.QueueRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueRef</span></code></a> returned (via Deferred) from <a class="reference internal" href="#buildbot.mq.base.MQConnector.startConsuming" title="buildbot.mq.base.MQConnector.startConsuming"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startConsuming()</span></code></a> can be used to stop consuming messages when they are no longer needed.
Users should be <em>very</em> careful to ensure that consumption is terminated in all cases.</p>
<dl class="method">
<dt id="buildbot.mq.base.QueueRef.stopConsuming">
<code class="sig-name descname">stopConsuming</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#buildbot.mq.base.QueueRef.stopConsuming" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop invoking the <code class="docutils literal notranslate"><span class="pre">callback</span></code> passed to <a class="reference internal" href="#buildbot.mq.base.MQConnector.startConsuming" title="buildbot.mq.base.MQConnector.startConsuming"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startConsuming()</span></code></a>.
This method can be called multiple times for the same <a class="reference internal" href="#buildbot.mq.base.QueueRef" title="buildbot.mq.base.QueueRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">QueueRef</span></code></a> instance without harm.</p>
<p>This method potentially returns a Deferred.</p>
<p>After the first call to this method has returned, the callback will not be invoked.</p>
</dd></dl>

</dd></dl>

<div class="section" id="implementations">
<h3>Implementations<a class="headerlink" href="#implementations" title="Permalink to this headline">¶</a></h3>
<p>Several concrete implementations of the MQ connector exist.
The simplest is intended for cases where only one master exists, similar to the SQLite database support.
The remainder use various existing queueing applications to support distributed communications.</p>
<div class="section" id="module-buildbot.mq.simple">
<span id="simple"></span><h4>Simple<a class="headerlink" href="#module-buildbot.mq.simple" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="buildbot.mq.simple.SimpleMQ">
<em class="property">class </em><code class="sig-prename descclassname">buildbot.mq.simple.</code><code class="sig-name descname">SimpleMQ</code><a class="headerlink" href="#buildbot.mq.simple.SimpleMQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#buildbot.mq.simple.SimpleMQ" title="buildbot.mq.simple.SimpleMQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleMQ</span></code></a> class implements a local equivalent of a message-queueing server.
It is intended for Buildbot installations with only one master.</p>
</dd></dl>

</div>
<div class="section" id="module-buildbot.mq.wamp">
<span id="wamp"></span><h4>Wamp<a class="headerlink" href="#module-buildbot.mq.wamp" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="buildbot.mq.wamp.WampMQ">
<em class="property">class </em><code class="sig-prename descclassname">buildbot.mq.wamp.</code><code class="sig-name descname">WampMQ</code><a class="headerlink" href="#buildbot.mq.wamp.WampMQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#buildbot.mq.wamp.WampMQ" title="buildbot.mq.wamp.WampMQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">WampMQ</span></code></a> class implements message-queueing using a wamp router.
This class translates the semantics of the buildbot mq api to the semantics of the wamp messaging system.
The message route is translated to a wamp topic by joining with dot and prefixing with buildbot namespace.
Example message that is sent via wamp is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">topic</span> <span class="o">=</span> <span class="s2">&quot;org.buildbot.mq.builds.1.new&quot;</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;builderid&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;buildid&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">&#39;buildrequestid&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span>
    <span class="s1">&#39;workerid&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="s1">&#39;complete&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
    <span class="s1">&#39;complete_at&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="s1">&#39;masterid&#39;</span><span class="p">:</span> <span class="mi">824</span><span class="p">,</span>
    <span class="s1">&#39;number&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">&#39;results&#39;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="s1">&#39;started_at&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">&#39;state_string&#39;</span><span class="p">:</span> <span class="sa">u</span><span class="s1">&#39;created&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-buildbot.wamp.connector"></span><dl class="class">
<dt id="buildbot.wamp.connector.WampConnector">
<em class="property">class </em><code class="sig-prename descclassname">buildbot.wamp.connector.</code><code class="sig-name descname">WampConnector</code><a class="headerlink" href="#buildbot.wamp.connector.WampConnector" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#buildbot.wamp.connector.WampConnector" title="buildbot.wamp.connector.WampConnector"><code class="xref py py-class docutils literal notranslate"><span class="pre">WampConnector</span></code></a> class implements a buildbot service for wamp.
It is managed outside of the mq module as this protocol can also be reused for worker protocol.
The connector support queuing of requests until the wamp connection is created, but do not support disconnection and reconnection.
Reconnection will be supported as part of a next release of AutobahnPython (<a class="reference external" href="https://github.com/crossbario/autobahn-python/issues/295">https://github.com/crossbario/autobahn-python/issues/295</a>).
There is a chicken and egg problem at the buildbot initialization phases, so the produce messages are actually not sent with deferred.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="queue-schema">
<span id="id2"></span><h2>Queue Schema<a class="headerlink" href="#queue-schema" title="Permalink to this headline">¶</a></h2>
<p>Buildbot uses a particularly simple architecture: in AMQP terms, all messages are sent to a single topic exchange, and consumers define anonymous queues bound to that exchange.</p>
<p>In future versions of Buildbot, some components (e.g., schedulers) may use durable queues to ensure that messages are not lost when one or more masters are disconnected.</p>
</div>
<div class="section" id="message-schema">
<span id="id3"></span><h2>Message Schema<a class="headerlink" href="#message-schema" title="Permalink to this headline">¶</a></h2>
<p>This section describes the general structure messages.
The specific routing keys and content of each message are described in the relevant sub-section of <a class="reference internal" href="data.html#data-api"><span class="std std-ref">Data API</span></a>.</p>
<div class="section" id="routing-keys">
<h3>Routing Keys<a class="headerlink" href="#routing-keys" title="Permalink to this headline">¶</a></h3>
<p>Routing keys are a sequence of strings, usually written with dot separators.
Routing keys are represented with variables when one or more of the words in the key are defined by the content of the message.
For example, <code class="docutils literal notranslate"><span class="pre">buildset.$bsid</span></code> describes routing keys such as <code class="docutils literal notranslate"><span class="pre">buildset.1984</span></code>, where 1984 is the ID of the buildset described by the message body.
Internally, keys are represented as tuples of strings.</p>
</div>
<div class="section" id="body-format">
<h3>Body Format<a class="headerlink" href="#body-format" title="Permalink to this headline">¶</a></h3>
<p>Message bodies are encoded in JSON.
The top level of each message is an object (a dictionary).</p>
<p>Most simple Python types - strings, numbers, lists, and dictionaries - are mapped directly to the corresponding JSON types.
Timestamps are represented as seconds since the UNIX epoch in message bodies.</p>
</div>
<div class="section" id="cautions">
<h3>Cautions<a class="headerlink" href="#cautions" title="Permalink to this headline">¶</a></h3>
<p>Message ordering is generally maintained by the backend implementations, but this should not be depended on.
That is, messages originating from the same master are <em>usually</em> delivered to consumers in the order they were produced.
Thus, for example, a consumer can expect to see a build request claimed before it is completed.
That said, consumers should be resilient to messages delivered out of order, at the very least by scheduling a “reload” from state stored in the database when messages arrive in an invalid order.</p>
<p>Unit tests should be used to ensure this resiliency.</p>
<p>Some related messages are sent at approximately the same time.
Due to the non-blocking nature of message delivery, consumers should <em>not</em> assume that subsequent messages in a sequence remain queued.
For example, upon receipt of a <code class="docutils literal notranslate"><span class="pre">buildset.$bsid.new</span></code> message, it is already too late to try to subscribe to the associated build requests messages, as they may already have been consumed.</p>
</div>
<div class="section" id="schema-changes">
<h3>Schema Changes<a class="headerlink" href="#schema-changes" title="Permalink to this headline">¶</a></h3>
<p>Future versions of Buildbot may add keys to messages, or add new messages.
Consumers should expect unknown keys and, if using wildcard topics, unknown messages.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, junpengxu

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>